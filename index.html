<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>TopoJSON Viewer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <script src="https://unpkg.com/simplify-js@1.2.4/simplify.js"></script>
  <style>
    html,
    body,
    #map {
      height: 100%;
      margin: 0;
    }

    .ctrl {
      position: fixed;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.7);
      padding: 8px;
      border-radius: 4px;
      font-size: 13px;
    }

    #main {
      top: 10px;
      left: 10px;
      width: 450px;
    }

    #kml {
      top: 10px;
      right: 10px;
      width: 180px;
    }

    input,
    button,
    select {
      margin: 2px;
      padding: 4px;
      font-size: 12px;
    }

    input[type="color"] {
      width: 25px;
      height: 25px;
      padding: 0;
    }

    .url-row {
      display: flex;
      align-items: center;
      gap: 4px;
      margin: 2px 0;
    }

    .url-row input[type="text"] {
      flex: 1;
    }

    .selected {
      stroke: #f00 !important;
      stroke-width: 3px !important;
      fill-opacity: 0 !important;
    }

    .msg {
      color: #666;
      font-size: 11px;
    }

    .error {
      color: #d00;
    }

    .address-label {
      white-space: nowrap;
      font-weight: bolder;
    }

    .address-label div {
      transform-origin: 0% 50%;
      background-color: rgb(255, 255, 255);
      border: 0.1px solid #ccccccc9;
      border-radius: 2px;
      padding: 0.1px 0.3px;
      color: #333;
      transition: font-size 0.1s ease;
    }
  </style>
</head>

<body>
  <div id="main" class="ctrl">
    <div>
      <button id="loadBtn">Load</button>
      <button id="clearBtn">Clear</button>
      <button id="shareBtn">Copy</button>
      <a href="https://geoshape.ex.nii.ac.jp/ka/resource/" target="_blank">Geo Data</a>
    </div>
    <div id="urls"></div>
    <div>Search: <input id="search" placeholder="Address"> <button id="searchBtn">Go</button></div>
    <div id="msg" class="msg"></div>
  </div>

  <div id="kml" class="ctrl">
    <label><input type="checkbox" id="kmlMode"> KML Mode</label><br>
    <label><input type="checkbox" id="showAddress"> Show Address</label><br>
    <label><input type="checkbox" id="simplify"> Simplify</label>
    <input type="number" id="tolerance" value="0.0001" step="0.0001" style="width:70px"><br>
    <input id="title" placeholder="Title" style="width:120px"><br>
    <button id="exportKmlBtn">Export KML</button>
  </div>

  <button id="toggleUI"
    style="position:fixed; top:10px; right:210px; z-index:1001; padding:4px 8px; font-size:12px;">Hide UI</button>

  <div id="map"></div>

  <script>
    (function () {
      'use strict';

      // --- 定数定義 ---
      const INITIAL_VIEW = { center: [36.2, 138.3], zoom: 5 };
      const TILE_LAYER_URL = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
      const TILE_LAYER_ATTRIBUTION = '<a href="https://www.openstreetmap.org/about/">(C)OpenStreetMap</a>';
      const KANJI_MAP = { '零': 0, '〇': 0, '一': 1, '壱': 1, '二': 2, '弐': 2, '三': 3, '参': 3, '四': 4, '五': 5, '六': 6, '七': 7, '八': 8, '九': 9, '十': 10, '拾': 10, '百': 100, '千': 1000, '万': 10000 };

      // --- DOM要素のキャッシュ ---
      const dom = {
        mapContainer: document.getElementById('map'),
        urlsContainer: document.getElementById('urls'),
        msgEl: document.getElementById('msg'),
        mainCtrl: document.getElementById('main'),
        kmlCtrl: document.getElementById('kml'),
        loadBtn: document.getElementById('loadBtn'),
        clearBtn: document.getElementById('clearBtn'),
        shareBtn: document.getElementById('shareBtn'),
        searchBtn: document.getElementById('searchBtn'),
        searchInput: document.getElementById('search'),
        exportKmlBtn: document.getElementById('exportKmlBtn'),
        kmlModeCheck: document.getElementById('kmlMode'),
        showAddressCheck: document.getElementById('showAddress'),
        simplifyCheck: document.getElementById('simplify'),
        toleranceInput: document.getElementById('tolerance'),
        titleInput: document.getElementById('title'),
        toggleUIBtn: document.getElementById('toggleUI'),
      };

      // --- アプリケーションの状態管理 ---
      const state = {
        map: null,
        layers: [],
        featureData: new Map(),
        selectedLayers: new Set(),
        marker: null,
        addressLabels: new Map(),
        hiddenAddressLabels: new Map(),
        currentHoverLabel: null,
        isCtrlPressed: false,
        currentHoverLayer: null,
        persistedSelectedFeatures: new Set(),
        sessionId: Date.now() + '_' + Math.random().toString(36).substr(2, 9)
      };

      // --- 状態保存・復元関数 ---
      const saveState = () => {
        try {
          const stateData = {
            urls: getUrls(),
            selectedFeatures: Array.from(state.persistedSelectedFeatures),
            mapView: {
              center: state.map.getCenter(),
              zoom: state.map.getZoom()
            },
            settings: {
              kmlMode: dom.kmlModeCheck.checked,
              showAddress: dom.showAddressCheck.checked,
              simplify: dom.simplifyCheck.checked,
              tolerance: dom.toleranceInput.value,
              title: dom.titleInput.value
            },
            sessionId: state.sessionId,
            timestamp: Date.now()
          };

          localStorage.setItem('topojsonViewerState', JSON.stringify(stateData));
          console.log('State saved to localStorage:', stateData);
        } catch (e) {
          console.error('Failed to save state:', e);
        }
      };

      const loadState = () => {
        try {
          const stateData = JSON.parse(localStorage.getItem('topojsonViewerState'));
          if (!stateData) return false;

          if (stateData.urls && stateData.urls.length > 0) {
            stateData.urls.forEach(u => addUrlRow(u.url, u.color));
          }

          state.persistedSelectedFeatures = new Set(stateData.selectedFeatures || []);

          if (stateData.mapView) {
            state.map.setView([stateData.mapView.center.lat, stateData.mapView.center.lng], stateData.mapView.zoom);
          }

          if (stateData.settings) {
            dom.kmlModeCheck.checked = stateData.settings.kmlMode || false;
            dom.showAddressCheck.checked = stateData.settings.showAddress || false;
            dom.simplifyCheck.checked = stateData.settings.simplify || false;
            dom.toleranceInput.value = stateData.settings.tolerance || '0.0001';
            dom.titleInput.value = stateData.settings.title || '';
            if (stateData.settings.title) {
              document.title = stateData.settings.title;
            }
          }

          console.log('State loaded from localStorage:', stateData);
          return true;
        } catch (e) {
          console.error('Failed to load state:', e);
          return false;
        }
      };

      const getFeatureId = (feature, layerIndex = 0) => {
        const props = feature.properties || {};
        const candidates = [
          props.id,
          props.ID,
          props.name,
          props.S_NAME,
          props.N03_004,
          props.PREF_NAME + '_' + props.CITY_NAME + '_' + props.S_NAME,
          JSON.stringify(feature.geometry.coordinates[0]?.[0])
        ].filter(Boolean);

        return candidates[0] || `feature_${layerIndex}_${Date.now()}_${Math.random()}`;
      };

      // --- ヘルパー関数 ---
      const randomColor = () => '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
      const convertKanji = s => s.replace(/[〇零一壱二弐三参四五六七八九十拾百千万]+/g, m => {
        let v = 0, n = 0;
        for (const c of m) {
          if (KANJI_MAP[c] >= 10) { v += (n || 1) * KANJI_MAP[c]; n = 0; }
          else { n = KANJI_MAP[c]; }
        }
        return v + n;
      });
      const getFontSizeForZoom = (zoom) => Math.max(2, Math.min(18, 3 + 14 * Math.pow(Math.max(0, Math.min(1, (zoom - 2) / 16)), 2)));

      const escapeXml = str => str.replace(/[<>&'"]/g, c => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', "'": '&apos;', '"': '&quot;' }[c]));
      const showMessage = (text, isError = false) => {
        dom.msgEl.textContent = text;
        dom.msgEl.className = `msg${isError ? ' error' : ''}`;
      };

      // --- ラベル表示関連 ---
      const createLabelIcon = (name, fontSize) => L.divIcon({
        className: 'address-label',
        html: `<div style="font-size: ${fontSize}px;">${name}</div>`,
        iconSize: [null, null],
        iconAnchor: [25, 25]
      });

      const showAddressLabel = (layer) => {
        const layerId = L.Util.stamp(layer);
        const data = state.featureData.get(layerId);
        if (!data) return;

        let center = getFeatureLabelPosition(data.feature) || layer.getBounds().getCenter();
        const fontSize = getFontSizeForZoom(state.map.getZoom());
        const labelMarker = L.marker(center, { icon: createLabelIcon(data.name, fontSize) }).addTo(state.map);
        state.addressLabels.set(layerId, labelMarker);
        updateLabelRotations();
      };

      const hideAddressLabel = (layer) => {
        const layerId = L.Util.stamp(layer);
        const labelMarker = state.addressLabels.get(layerId);
        if (labelMarker) {
          state.map.removeLayer(labelMarker);
          state.addressLabels.delete(layerId);
        }
      };

      const toggleAddressDisplay = () => {
        if (dom.showAddressCheck.checked) {
          state.selectedLayers.forEach(layer => showAddressLabel(layer));
        } else {
          state.addressLabels.forEach(labelMarker => state.map.removeLayer(labelMarker));
          state.addressLabels.clear();
        }
        saveState();
      };

      const showHoverAddressLabel = (layer) => {
        hideHoverAddressLabel();
        const data = state.featureData.get(L.Util.stamp(layer));
        if (!data) return;

        const address = data.name;
        if (!address) return;

        const center = getFeatureLabelPosition(data.feature) || layer.getBounds().getCenter();
        const fontSize = getFontSizeForZoom(state.map.getZoom());
        state.currentHoverLabel = L.marker(center, { icon: createLabelIcon(address, fontSize) }).addTo(state.map);
        updateLabelRotations();
      };

      const hideHoverAddressLabel = () => {
        if (state.currentHoverLabel) {
          state.map.removeLayer(state.currentHoverLabel);
          state.currentHoverLabel = null;
        }
      };

      function updateLabelRotations() {
        const labels = [...state.addressLabels.values(), ...state.currentHoverLabel ? [state.currentHoverLabel] : []];
        const baseFontSize = getFontSizeForZoom(state.map.getZoom());

        labels.forEach((markerA, i) => {
          const aPixel = state.map.latLngToContainerPoint(markerA.getLatLng());
          let maxAngle = 0;
          let finalFontSize = baseFontSize;

          labels.forEach((markerB, j) => {
            if (i === j) return;
            const bPixel = state.map.latLngToContainerPoint(markerB.getLatLng());
            const dx = aPixel.x - bPixel.x;
            const dy = aPixel.y - bPixel.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 100) {
              const angle = 30 * (100 - dist) / 100;
              if (Math.abs(angle) > Math.abs(maxAngle)) maxAngle = angle;

              const sizeFactor = (100 - dist) / 100;
              const newSize = baseFontSize * (1 - sizeFactor * 0.4);
              if (newSize < finalFontSize) {
                finalFontSize = newSize;
              }
            }
          });
          const div = markerA.getElement()?.querySelector('div');
          if (div) {
            div.style.transform = `rotate(${maxAngle}deg)`;
            div.style.fontSize = `${finalFontSize}px`;
          }
        });
      }

      // --- URL & UI ---
      const getUrls = () => Array.from(dom.urlsContainer.querySelectorAll('.url-row')).map(row => ({
        url: row.querySelector('input[type="text"]').value.trim(),
        color: row.querySelector('input[type="color"]').value
      })).filter(x => x.url);

      const updateUrlParams = () => {
        const urls = getUrls();
        const params = new URLSearchParams(location.search);
        if (urls.length) params.set('urls', encodeURIComponent(JSON.stringify(urls)));
        else params.delete('urls');
        history.replaceState({}, '', params.toString() ? `?${params}` : location.pathname);
        saveState();
      };

      function addUrlRow(url = '', color = '') {
        const row = document.createElement('div');
        row.className = 'url-row';
        row.innerHTML = `<button class="add">+</button><input type="text" value="${url}" placeholder="TopoJSON URL">
                     <input type="color" value="${color || randomColor()}">
                     <button class="remove">-</button>`;

        row.querySelector('.add').addEventListener('click', () => addUrlRow());
        row.querySelector('.remove').addEventListener('click', () => {
          row.remove();
          updateUrlParams();
        });
        row.querySelector('input[type="text"]').addEventListener('change', updateUrlParams);
        row.querySelector('input[type="color"]').addEventListener('change', updateUrlParams);

        dom.urlsContainer.appendChild(row);
        updateUrlParams();
      }

      const shareUrl = () => {
        updateUrlParams();
        navigator.clipboard?.writeText(location.href)
          .then(() => showMessage('URL copied'))
          .catch(() => showMessage('Copy failed', true));
      };

      const toggleUI = () => {
        const isHidden = dom.mainCtrl.style.display === 'none';
        const display = isHidden ? 'block' : 'none';
        dom.mainCtrl.style.display = display;
        dom.kmlCtrl.style.display = display;
        dom.toggleUIBtn.textContent = isHidden ? 'Hide UI' : 'Show UI';
      };

      // --- データ読み込み & 処理 ---
      async function loadAll() {
        if (dom.kmlModeCheck.checked && state.selectedLayers.size > 0) {
          if (!confirm('KMLモードが有効です。\nLoadを実行すると選択がリセットされます。続行しますか？')) return;
        }
        const urls = getUrls();
        if (!urls.length) return showMessage('No URLs');

        showMessage('Loading...');
        clearMap(false);

        let layerIndex = 0;
        for (const { url, color } of urls) {
          try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
            const topo = await res.json();
            const key = Object.keys(topo.objects)[0];
            let geo = topojson.feature(topo, topo.objects[key]);

            if (dom.simplifyCheck.checked) {
              geo = simplifyGeo(geo, +dom.toleranceInput.value);
            }

            const layerGroup = L.geoJSON(geo, {
              style: { color, weight: 1, opacity: 0.7, fillOpacity: 0.15 },
              onEachFeature: (feature, layer) => setupFeatureEvents(feature, layer, color, layerIndex)
            }).addTo(state.map);
            state.layers.push(layerGroup);
            layerIndex++;
          } catch (e) {
            console.error(e);
            showMessage('Load error: ' + url, true);
          }
        }

        if (state.layers.length) {
          const group = new L.featureGroup(state.layers.flatMap(l => l.getLayers()));
          if (group.getLayers().length > 0) {
            state.map.fitBounds(group.getBounds());
          }
        }

        setTimeout(() => {
          restoreSelectedFeatures();
          showMessage('Ready');
        }, 100);
      }

      function restoreSelectedFeatures() {
        if (state.persistedSelectedFeatures.size === 0) return;

        state.featureData.forEach((data, layerId) => {
          if (state.persistedSelectedFeatures.has(data.featureId)) {
            toggleSelect(data.layer, false);
          }
        });

        console.log(`Restored ${state.selectedLayers.size} selected features`);
      }

      function setupFeatureEvents(feature, layer, color, layerIndex = 0) {
        const layerId = L.Util.stamp(layer);
        const name = getName(feature);
        const featureId = getFeatureId(feature, layerIndex);

        state.featureData.set(layerId, { feature, layer, color, name, featureId });

        layer.on('click', e => {
          if (dom.kmlModeCheck.checked && (e.originalEvent.ctrlKey || e.originalEvent.metaKey)) {
            L.DomEvent.stopPropagation(e);
            toggleSelect(layer);
          }
        });

        layer.on('mouseover', (e) => {
          state.currentHoverLayer = layer;
          if (!state.isCtrlPressed) {
            showHoverAddressLabel(layer);
          }
          if (!state.selectedLayers.has(layer)) {
            layer.setStyle({ fillOpacity: 0.4 });
          }
        });

        layer.on('mouseout', () => {
          hideHoverAddressLabel();
          state.currentHoverLayer = null;
          if (!state.selectedLayers.has(layer)) {
            layer.setStyle({ fillOpacity: 0.15 });
          }
        });
      }

      function setupKeyEvents() {
        document.addEventListener('keydown', (e) => {
          if (e.ctrlKey || e.metaKey) {
            if (!state.isCtrlPressed) {
              state.isCtrlPressed = true;
              hideHoverAddressLabel();
              state.addressLabels.forEach((labelMarker, layerId) => {
                state.map.removeLayer(labelMarker);
                state.hiddenAddressLabels.set(layerId, labelMarker);
              });
              state.addressLabels.clear();
            }
          }
        });

        document.addEventListener('keyup', (e) => {
          if (!e.ctrlKey && !e.metaKey && state.isCtrlPressed) {
            state.isCtrlPressed = false;
            if (state.currentHoverLayer) {
              showHoverAddressLabel(state.currentHoverLayer);
            }
            if (dom.showAddressCheck.checked) {
              state.hiddenAddressLabels.forEach((labelMarker, layerId) => {
                const layer = state.featureData.get(layerId)?.layer;
                if (layer && state.selectedLayers.has(layer)) {
                  showAddressLabel(layer);
                }
              });
            }
            state.hiddenAddressLabels.clear();
          }
        });
      }

      const simplifyGeo = (geo, tolerance) => {
        const simpRing = ring => simplify(ring.map(([x, y]) => ({ x, y })), tolerance, true).map(p => [p.x, p.y]);
        const simpPoly = poly => poly.map(simpRing);
        const simpGeom = g => {
          if (g.type === 'Polygon') return { ...g, coordinates: simpPoly(g.coordinates) };
          if (g.type === 'MultiPolygon') return { ...g, coordinates: g.coordinates.map(simpPoly) };
          return g;
        };
        return { ...geo, features: geo.features.map(f => ({ ...f, geometry: simpGeom(f.geometry) })) };
      };

      const getName = feature => convertKanji(feature.properties?.name || feature.properties?.S_NAME || feature.properties?.N03_004 || 'Feature');

      function toggleSelect(layer, shouldSave = true) {
        const layerId = L.Util.stamp(layer);
        const data = state.featureData.get(layerId);

        if (state.selectedLayers.has(layer)) {
          state.selectedLayers.delete(layer);
          layer.getElement().classList.remove('selected');
          layer.setStyle({ fillOpacity: 0.15 });
          hideAddressLabel(layer);
          if (data) {
            state.persistedSelectedFeatures.delete(data.featureId);
          }
        } else {
          state.selectedLayers.add(layer);
          layer.getElement().classList.add('selected');
          if (dom.showAddressCheck.checked) {
            showAddressLabel(layer);
          }
          if (data) {
            state.persistedSelectedFeatures.add(data.featureId);
          }
        }

        if (shouldSave) {
          saveState();
        }
      }

      function clearMap(clearUrls = true) {
        state.layers.forEach(l => state.map.removeLayer(l));
        state.addressLabels.forEach(marker => state.map.removeLayer(marker));
        hideHoverAddressLabel();
        if (state.marker) state.map.removeLayer(state.marker);

        state.layers = [];
        state.featureData.clear();
        state.selectedLayers.clear();
        state.addressLabels.clear();
        state.marker = null;

        if (clearUrls) {
          dom.urlsContainer.innerHTML = '';
          addUrlRow();
          updateUrlParams();
          state.persistedSelectedFeatures.clear();
        }
        showMessage('');

        if (clearUrls) {
          saveState();
        }
      }

      const clearAll = () => {
        if (confirm('すべてのデータをクリアします。よろしいですか？')) {
          clearMap(true);
          localStorage.removeItem('topojsonViewerState');
        }
      };

      async function searchAddress() {
        const query = dom.searchInput.value.trim();
        if (!query) return;

        try {
          const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`);
          const data = await res.json();
          if (!data.length) return showMessage('Not found');

          const { lat, lon, display_name } = data[0];
          if (state.marker) state.map.removeLayer(state.marker);
          state.marker = L.marker([lat, lon]).addTo(state.map).bindPopup(display_name).openPopup();
          state.map.setView([lat, lon], 17);
          showMessage('Found');
          saveState();
        } catch (e) {
          showMessage('Search error', true);
        }
      }

      function exportKml() {
        if (!state.selectedLayers.size) return;

        const coords2kml = coords => coords.map(c => `${c[0]},${c[1]},0`).join(' ');
        const makePoly = (exterior, holes = []) => {
          let p = `<Polygon><outerBoundaryIs><LinearRing><coordinates>${coords2kml(exterior)}</coordinates></LinearRing></outerBoundaryIs>`;
          holes.forEach(h => p += `<innerBoundaryIs><LinearRing><coordinates>${coords2kml(h)}</coordinates></LinearRing></innerBoundaryIs>`);
          return p + '</Polygon>';
        };

        let kmlContent = state.selectedLayers.reduce((acc, layer) => {
          const data = state.featureData.get(L.Util.stamp(layer));
          if (!data) return acc;

          const { feature, name } = data;
          const geom = feature.geometry;
          let placemark = `<Placemark><name>${escapeXml(name)}</name>`;

          if (geom.type === 'Polygon') {
            placemark += makePoly(geom.coordinates[0], geom.coordinates.slice(1));
          } else if (geom.type === 'MultiPolygon') {
            geom.coordinates.forEach(poly => placemark += makePoly(poly[0], poly.slice(1)));
          }
          placemark += '</Placemark>';
          return acc + placemark;
        }, '');

        const kml = `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document>${kmlContent}</Document></kml>`;
        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = (dom.titleInput.value || 'features') + '.kml';
        a.click();
        URL.revokeObjectURL(a.href);
      }

      // --- ポリゴン関連のヘルパー関数 ---
      const pointInPolygon = (point, coordinates) => {
        const [px, py] = point;
        let inside = false;
        const ring = coordinates[0];
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const [xi, yi] = ring[i];
          const [xj, yj] = ring[j];
          if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
            inside = !inside;
          }
        }
        for (let h = 1; h < coordinates.length; h++) {
          const hole = coordinates[h];
          let inHole = false;
          for (let i = 0, j = hole.length - 1; i < hole.length; j = i++) {
            const [xi, yi] = hole[i];
            const [xj, yj] = hole[j];
            if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
              inHole = !inHole;
            }
          }
          if (inHole) inside = false;
        }
        return inside;
      };

      const pointToPolygonDistance = (point, coordinates) => {
        const [px, py] = point;
        let minDistSq = Infinity;
        for (const ring of coordinates) {
          for (let i = 0; i < ring.length - 1; i++) {
            const [x1, y1] = ring[i];
            const [x2, y2] = ring[i + 1];
            let dx = x2 - x1, dy = y2 - y1;
            let t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
            t = Math.max(0, Math.min(1, t));
            let closestX = x1 + t * dx;
            let closestY = y1 + t * dy;
            minDistSq = Math.min(minDistSq, (px - closestX) ** 2 + (py - closestY) ** 2);
          }
        }
        return Math.sqrt(minDistSq);
      };

      const getPolygonLabelPosition = (coordinates) => {
        if (!coordinates?.[0] || coordinates[0].length < 3) return null;
        const ring = coordinates[0];
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const [x, y] of ring) { minX = Math.min(minX, x); minY = Math.min(minY, y); maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); }
        const cellSize = Math.min(maxX - minX, maxY - minY) / 20;
        if (cellSize === 0) return null;
        let bestDist = 0, bestPoint = null;
        for (let x = minX; x <= maxX; x += cellSize) {
          for (let y = minY; y <= maxY; y += cellSize) {
            if (pointInPolygon([x, y], coordinates)) {
              const dist = pointToPolygonDistance([x, y], coordinates);
              if (dist > bestDist) { bestDist = dist; bestPoint = [x, y]; }
            }
          }
        }
        if (!bestPoint) return null;
        const fineSize = cellSize / 4;
        for (let x = bestPoint[0] - cellSize; x <= bestPoint[0] + cellSize; x += fineSize) {
          for (let y = bestPoint[1] - cellSize; y <= bestPoint[1] + cellSize; y += fineSize) {
            if (pointInPolygon([x, y], coordinates)) {
              const dist = pointToPolygonDistance([x, y], coordinates);
              if (dist > bestDist) { bestDist = dist; bestPoint = [x, y]; }
            }
          }
        }
        return [bestPoint[1], bestPoint[0]];
      };

      const getFeatureLabelPosition = (feature) => {
        const geom = feature.geometry;
        if (geom.type === 'Polygon') return getPolygonLabelPosition(geom.coordinates);
        if (geom.type === 'MultiPolygon') {
          let maxArea = 0, bestPosition = null;
          for (const polygon of geom.coordinates) {
            const position = getPolygonLabelPosition(polygon);
            if (position) {
              const ring = polygon[0];
              let area = 0;
              for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                area += (ring[j][0] + ring[i][0]) * (ring[j][1] - ring[i][1]);
              }
              if ((area /= 2) > maxArea) { maxArea = area; bestPosition = position; }
            }
          }
          return bestPosition;
        }
        return null;
      };

      function init() {
        state.map = L.map(dom.mapContainer, { zoomControl: false }).setView(INITIAL_VIEW.center, INITIAL_VIEW.zoom);
        L.tileLayer(TILE_LAYER_URL, { attribution: TILE_LAYER_ATTRIBUTION }).addTo(state.map);

        dom.loadBtn.addEventListener('click', loadAll);
        dom.clearBtn.addEventListener('click', clearAll);
        dom.shareBtn.addEventListener('click', shareUrl);
        dom.searchBtn.addEventListener('click', searchAddress);
        dom.searchInput.addEventListener('keypress', e => e.key === 'Enter' && searchAddress());
        dom.exportKmlBtn.addEventListener('click', exportKml);
        dom.toggleUIBtn.addEventListener('click', toggleUI);
        dom.showAddressCheck.addEventListener('change', toggleAddressDisplay);
        dom.kmlModeCheck.addEventListener('change', saveState);
        dom.simplifyCheck.addEventListener('change', saveState);
        dom.toleranceInput.addEventListener('input', saveState);
        dom.titleInput.addEventListener('input', () => {
          document.title = dom.titleInput.value || 'TopoJSON Viewer';
          saveState();
        });

        state.map.on('zoomend moveend', () => {
          updateLabelRotations();
          saveState();
        });

        setupKeyEvents();

        const stateLoaded = loadState();

        if (!stateLoaded) {
          const params = new URLSearchParams(location.search);
          const urlsParam = params.get('urls');
          if (urlsParam) {
            try {
              const urls = JSON.parse(decodeURIComponent(urlsParam));
              urls.forEach(u => addUrlRow(u.url, u.color));
              setTimeout(loadAll, 100);
            } catch (e) {
              console.error("Failed to load state from URL", e);
            }
          }
        } else {
          if (getUrls().length > 0) {
            setTimeout(loadAll, 100);
          }
        }

        if (dom.urlsContainer.children.length === 0) {
          addUrlRow();
        }

        window.addEventListener('beforeunload', saveState);
        setInterval(saveState, 1000);
      }

      document.addEventListener('DOMContentLoaded', init);
    })();
  </script>
</body>

</html>
